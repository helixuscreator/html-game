<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Match-3 mit Plop-Sound bei Match</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin:0; display:flex; flex-direction:column; align-items:center; font-family:Arial,sans-serif; background:#f5f5f5; }
  canvas { border:1px solid #333; margin-top:20px; touch-action: none; background:white; }
  #score { font-size:20px; margin-top:10px; }
  #startButton { font-size:16px; padding:10px 20px; margin-top:20px; }
</style>
</head>
<body>
<h1>Match-3 mit Plop-Sound bei Match</h1>
<canvas id="gameCanvas" width="360" height="360"></canvas>
<div id="score">Punkte: 0</div>
<button id="startButton">Spiel starten & Sound freigeben</button>

<audio id="plopSound" src="plop.mp3"></audio>
<audio id="bgMusic" src="background.mp3" loop></audio>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const plopSound = document.getElementById('plopSound');
const bgMusic = document.getElementById('bgMusic');
const startButton = document.getElementById('startButton');

const rows = 6;
const cols = 6;
const cellSize = canvas.width / cols;
const colors = ['red','green','blue','yellow','orange','purple'];

let grid = [];
let score = 0;
let animating = false;
const scoreEl = document.getElementById('score');
let first = null;

// Zeichnen
function drawGrid(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      let item = grid[r][c];
      ctx.fillStyle = item.color;
      ctx.fillRect(item.x*cellSize, item.y*cellSize, cellSize-2, cellSize-2);
      if(first && first[0]===r && first[1]===c){
        ctx.strokeStyle='white'; ctx.lineWidth=3;
        ctx.strokeRect(item.x*cellSize+1,item.y*cellSize+1,cellSize-4,cellSize-4);
      }
    }
  }
}

// Grid initialisieren
function initGrid(){
  grid=[];
  for(let r=0;r<rows;r++){
    let row=[];
    for(let c=0;c<cols;c++){
      row.push({color: colors[Math.floor(Math.random()*colors.length)], x:c, y:r});
    }
    grid.push(row);
  }
  resolveMatches();
}

// Matches finden
function findMatches(){
  let matched=[];
  for(let r=0;r<rows;r++){
    let count=1;
    for(let c=1;c<cols;c++){
      if(grid[r][c].color===grid[r][c-1].color){count++;}
      else {if(count>=3) for(let k=0;k<count;k++) matched.push([r,c-1-k]); count=1;}
    }
    if(count>=3) for(let k=0;k<count;k++) matched.push([r,cols-1-k]);
  }
  for(let c=0;c<cols;c++){
    let count=1;
    for(let r=1;r<rows;r++){
      if(grid[r][c].color===grid[r-1][c].color){count++;}
      else {if(count>=3) for(let k=0;k<count;k++) matched.push([r-1-k,c]); count=1;}
    }
    if(count>=3) for(let k=0;k<count;k++) matched.push([rows-1-k,c]);
  }
  return matched;
}

// Matches auflösen
function resolveMatches(){
  let matched=findMatches();
  if(matched.length===0) return false;
  
  plopSound.currentTime=0; plopSound.play();
  
  animating=true;
  let points=Math.min(3,Math.floor(matched.length/3));
  score+=points;
  scoreEl.textContent=`Punkte: ${score}`;
  
  for(let [r,c] of matched) grid[r][c].color=null;
  animateFalling();
  return true;
}

// Items fallen lassen
function animateFalling(){
  for(let c=0;c<cols;c++){
    for(let r=rows-1;r>=0;r--){
      if(grid[r][c].color===null){
        for(let k=r-1;k>=0;k--){
          if(grid[k][c].color!==null){grid[r][c].color=grid[k][c].color; grid[k][c].color=null; grid[r][c].y=k; break;}
        }
      }
    }
    for(let r=0;r<rows;r++){
      if(grid[r][c].color===null){grid[r][c].color=colors[Math.floor(Math.random()*colors.length)]; grid[r][c].y=-1;}
    }
  }
  let done=false;
  function step(){
    done=true;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        let item=grid[r][c];
        if(item.y<r){item.y+=0.2; if(item.y>r)item.y=r; done=false;}
      }
    }
    drawGrid();
    if(!done) requestAnimationFrame(step);
    else {animating=false; if(resolveMatches()) return; checkNoMoves();}
  }
  requestAnimationFrame(step);
}

// Prüfen ob noch mögliche Züge
function checkNoMoves(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      let neighbors=[[r+1,c],[r-1,c],[r,c+1],[r,c-1]];
      for(let [nr,nc] of neighbors){
        if(nr>=0 && nr<rows && nc>=0 && nc<cols){
          [grid[r][c].color,grid[nr][nc].color]=[grid[nr][nc].color,grid[r][c].color];
          if(findMatches().length>0){[grid[r][c].color,grid[nr][nc].color]=[grid[nr][nc].color,grid[r][c].color]; return; }
          [grid[r][c].color,grid[nr][nc].color]=[grid[nr][nc].color,grid[r][c].color];
        }
      }
    }
  }
  shuffleAnimation();
}

// Swap-Animation nur 1s bei möglich Match
function animateSwap(r1,c1,r2,c2){
  if(animating) return;
  animating = true;

  const item1 = grid[r1][c1], item2 = grid[r2][c2];
  const frames = 10;
  let step=0;

  function stepSwap(){
    step++;
    let dx=(c2-c1)/frames, dy=(r2-r1)/frames;
    item1.x=c1+dx*step; item1.y=r1+dy*step;
    item2.x=c2-dx*step; item2.y=r2-dy*step;
    drawGrid();
    if(step<frames) requestAnimationFrame(stepSwap);
    else{
      // Prüfen, ob Match entsteht
      [item1.color,item2.color]=[item2.color,item1.color];
      drawGrid();
      if(findMatches().length>0){
        setTimeout(()=>{
          plopSound.currentTime=0; plopSound.play();
          resolveMatches();
          animating=false;
        }, 1000);
      } else {
        // Kein Match: sofort zurück
        [item1.color,item2.color]=[item2.color,item1.color];
        drawGrid();
        animating=false;
      }
    }
  }
  requestAnimationFrame(stepSwap);
}

// Auswahl
canvas.addEventListener('mousedown', startSelect);
canvas.addEventListener('touchstart', e=>{e.preventDefault(); startSelect(e.touches[0]);});
function startSelect(e){
  if(animating) return;
  const rect=canvas.getBoundingClientRect();
  const c=Math.floor((e.clientX-rect.left)/cellSize);
  const r=Math.floor((e.clientY-rect.top)/cellSize);
  if(!first) first=[r,c]; else {
    const [r0,c0]=first;
    if(Math.abs(r-r0)+Math.abs(c-c0)===1) animateSwap(r0,c0,r,c);
    first=null;
  }
  drawGrid();
}

// Button starten
startButton.addEventListener('click',()=>{
  bgMusic.currentTime=0;
  bgMusic.volume=0.3;
  bgMusic.play();

  startButton.style.display='none';
  initGrid();
});
</script>
</body>
</html>
