<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Peace Monkey</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root{
    --board-size: 450px;
    --canvas-size: 360px;
    --amplitude: 20px;
    --duration: 4s;
  }
  html,body{
    margin:0; padding:0;
    width:100%; height:100%;
    background:#000;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    font-family:Arial, sans-serif;
  }
  #board{
    position:relative;
    width:var(--board-size);
    height:var(--board-size);
    overflow:hidden;
  }
  #bgOverlay{
    position:absolute;
    left:50%; top:50%;
    width:450px; height:450px;
    transform:translate(-50%,-50%);
    object-fit:cover;
    z-index:1;
    pointer-events:none;
    animation: floatY var(--duration) ease-in-out infinite;
  }
  @keyframes floatY{
    0%   { transform: translate(-50%,-50%) translateY(calc(-1 * var(--amplitude))); }
    50%  { transform: translate(-50%,-50%) translateY(var(--amplitude)); }
    100% { transform: translate(-50%,-50%) translateY(calc(-1 * var(--amplitude))); }
  }
  #gameCanvas{
    position:absolute;
    left:50%; top:50%;
    width:var(--canvas-size);
    height:var(--canvas-size);
    transform:translate(-50%,-50%);
    image-rendering:auto;
    background:transparent;
    z-index:2;
    display:none;
  }
  #score,#timer{
    position:absolute; top:10px; font-size:20px; color:#fff; display:none; z-index:3;
    user-select:none;
  }
  #score{ right:10px; left:auto; }
  #timer{ left:10px; right:auto; }
  #endScore{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    font-size:42px; color:gold; display:none; text-align:center; z-index:4;
    pointer-events:none;
  }
  #controls { text-align:center; margin-top:15px; }
  #startButton {
    font-size:16px;
    padding:10px 20px;
    color:#fff;
    background:#222;
    border:none;
    cursor:pointer;
  }
</style>
</head>
<body>
<div id="board">
  <img id="bgOverlay" src="backgroundImage.png" alt="Hintergrund">
  <canvas id="gameCanvas" width="360" height="360"></canvas>
  <div id="score">Punkte: 0</div>
  <div id="timer">Zeit: 02:00</div>
  <div id="endScore"></div>
</div>
<div id="controls">
  <button id="startButton" disabled>Bilder laden…</button>
</div>
<audio id="plopSound" src="plop.mp3"></audio>
<audio id="bgMusic" src="background.mp3" loop></audio>
<audio id="failSound" src="failSound.mp3"></audio>
<audio id="endMusic" src="endMusic.mp3"></audio>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
canvas.width = 360; canvas.height = 360;

const startButton = document.getElementById('startButton');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const endScoreEl = document.getElementById('endScore');

const plopSound = document.getElementById('plopSound');
const bgMusic = document.getElementById('bgMusic');
const failSound = document.getElementById('failSound');
const endMusic = document.getElementById('endMusic');

const COLS = 8, ROWS = 8;
const CANVAS_SIZE = 360;
const CELL = CANVAS_SIZE / COLS;
const imageSources = ["item1.png","item2.png","item3.png","item4.png"];
let images = [];

let grid = [];
let score = 0;
let animating = false;
let first = null;
let timer = 120;
let timerInterval = null;
let gameEnded = false;

async function preloadImages(list){
  startButton.disabled = true;
  startButton.textContent = "Bilder laden…";
  images = await Promise.all(list.map(src => new Promise(resolve=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = ()=>resolve(null);
    img.src = src;
  })));
  startButton.disabled = false;
  startButton.textContent = "Spiel starten";
}
preloadImages(imageSources);

function initGrid(){
  do {
    grid = [];
    for(let r=0;r<ROWS;r++){
      const row = [];
      for(let c=0;c<COLS;c++){
        let available = [];
        for(let k=0;k<images.length;k++) available.push(k);
        if(c>=2 && row[c-1].imgIndex === row[c-2].imgIndex) available = available.filter(i=>i!==row[c-1].imgIndex);
        if(r>=2 && grid[r-1][c].imgIndex === grid[r-2][c].imgIndex) available = available.filter(i=>i!==grid[r-1][c].imgIndex);
        const idx = available[Math.floor(Math.random()*available.length)];
        row.push({ imgIndex: idx, row: r, col: c, animX: c, animY: r, removed:false });
      }
      grid.push(row);
    }
  } while(findMatches().length>0 || !hasMoves());
}

function drawGrid(shrinkMap = {}){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(gameEnded) return;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const item = grid[r][c];
      if(!item) continue;
      let size = CELL - 2;
      if(first && first[0]===r && first[1]===c && !animating) size *= 0.8;
      if(shrinkMap[`${r}_${c}`]) size *= shrinkMap[`${r}_${c}`];
      const x = item.animX * CELL + (CELL - size)/2;
      const y = item.animY * CELL + (CELL - size)/2;
      const img = images[item.imgIndex];
      if(img) ctx.drawImage(img, x, y, size, size);
      else { ctx.fillStyle='#666'; ctx.fillRect(x,y,size,size);}
    }
  }
}

function findMatches(){
  const matched = [];
  for(let r=0;r<ROWS;r++){
    let count=1;
    for(let c=1;c<COLS;c++){
      if(grid[r][c].imgIndex===grid[r][c-1].imgIndex) count++;
      else { if(count>=3) for(let k=0;k<count;k++) matched.push([r,c-1-k]); count=1;}
    }
    if(count>=3) for(let k=0;k<count;k++) matched.push([r,COLS-1-k]);
  }
  for(let c=0;c<COLS;c++){
    let count=1;
    for(let r=1;r<ROWS;r++){
      if(grid[r][c].imgIndex===grid[r-1][c].imgIndex) count++;
      else { if(count>=3) for(let k=0;k<count;k++) matched.push([r-1-k,c]); count=1;}
    }
    if(count>=3) for(let k=0;k<count;k++) matched.push([ROWS-1-k,c]);
  }
  return matched;
}

function swapData(r1,c1,r2,c2){
  const t = grid[r1][c1].imgIndex;
  grid[r1][c1].imgIndex = grid[r2][c2].imgIndex;
  grid[r2][c2].imgIndex = t;
}

function hasMoves(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(c<COLS-1){ swapData(r,c,r,c+1); if(findMatches().length>0){ swapData(r,c,r,c+1); return true;} swapData(r,c,r,c+1);}
      if(r<ROWS-1){ swapData(r,c,r+1,c); if(findMatches().length>0){ swapData(r,c,r+1,c); return true;} swapData(r,c,r+1,c);}
    }
  }
  return false;
}

function resolveMatches(){
  if(gameEnded) return;
  const matched=findMatches();
  if(matched.length===0){ if(!hasMoves()) shuffleGrid(false); return;}
  try{plopSound.currentTime=0; plopSound.volume=1; plopSound.play();}catch(e){}
  animating=true;
  const shrinkMap={};
  const counted={};
  matched.forEach(([r,c])=>{ counted[`${r}_${c}`]=true; });
  const gained = Object.keys(counted).length;
  score+=gained;
  scoreEl.textContent=`Punkte: ${score}`;
  Object.keys(counted).forEach(key=>{ const [r,c]=key.split('_').map(Number); shrinkMap[key]=1; grid[r][c].removed=true; });
  function shrinkStep(){
    let done=true;
    for(const k in shrinkMap){ shrinkMap[k]-=0.06; if(shrinkMap[k]>0) done=false;}
    drawGrid(shrinkMap);
    if(!done) requestAnimationFrame(shrinkStep); else fallItems();
  }
  shrinkStep();
}

function fallItems(){
  for(let c=0;c<COLS;c++){
    let write=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(!grid[r][c].removed){
        if(write!==r){ grid[write][c].imgIndex=grid[r][c].imgIndex; grid[write][c].animY=r;}
        write--;
      }
    }
    for(let r=write;r>=0;r--){ grid[r][c].imgIndex=Math.floor(Math.random()*images.length); grid[r][c].animY=-1;}
    for(let r=0;r<ROWS;r++) grid[r][c].removed=false;
  }
  animateFalling();
}

function animateFalling(){
  animating=true;
  const duration=300;
  const start=performance.now();
  const starts=grid.map(row=>row.map(item=>item.animY));
  function step(ts){
    const t=Math.min((ts-start)/duration,1);
    for(let r=0;r<ROWS;r++){for(let c=0;c<COLS;c++){const item=grid[r][c]; item.animY=starts[r][c]*(1-t)+item.row*t;}}
    drawGrid();
    if(t<1) requestAnimationFrame(step); else { for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) grid[r][c].animY=grid[r][c].row; animating=false; if(!gameEnded) resolveMatches();}
  }
  requestAnimationFrame(step);
}

function shuffleGrid(playSound=true){
  animating=true;
  do{
    const all=[];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) all.push(grid[r][c].imgIndex);
    const copy=[...all];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const idx=Math.floor(Math.random()*copy.length);
        grid[r][c].imgIndex=copy.splice(idx,1)[0];
        grid[r][c].animX=c;
        grid[r][c].animY=r;
      }
    }
  } while(findMatches().length>0 || !hasMoves());
  drawGrid();
  animating=false;
}

function animateSwap(r1,c1,r2,c2){
  if(animating || gameEnded) return;
  animating=true;
  const a=grid[r1][c1], b=grid[r2][c2];
  const startA={x:a.animX, y:a.animY}, startB={x:b.animX, y:b.animY};
  const frames=12; let step=0;
  function doStep(){
    step++; const t=step/frames;
    a.animX=startA.x*(1-t)+startB.x*t; a.animY=startA.y*(1-t)+startB.y*t;
    b.animX=startB.x*(1-t)+startA.x*t; b.animY=startB.y*(1-t)+startA.y*t;
    drawGrid();
    if(step<frames) requestAnimationFrame(doStep); else {
      swapData(r1,c1,r2,c2);
      a.animX=a.col; a.animY=a.row; b.animX=b.col; b.animY=b.row;
      drawGrid();
      const matched=findMatches();
      if(matched.length>0) resolveMatches();
      else{
        try{failSound.currentTime=0; failSound.volume=1; failSound.play();}catch(e){}
        swapData(r1,c1,r2,c2);
        animateRevert(a,b,startA,startB,()=>{animating=false; drawGrid();});
      }
    }
  }
  requestAnimationFrame(doStep);
}

function animateRevert(aItem,bItem,origA,origB,cb){
  const frames=10; let step=0;
  const startA={x:aItem.animX, y:aItem.animY}, startB={x:bItem.animX, y:bItem.animY};
  function stepAnim(){
    step++; const t=step/frames;
    aItem.animX=startA.x*(1-t)+origA.x*t; aItem.animY=startA.y*(1-t)+origA.y*t;
    bItem.animX=startB.x*(1-t)+origB.x*t; bItem.animY=startB.y*(1-t)+origB.y*t;
    drawGrid();
    if(step<frames) requestAnimationFrame(stepAnim); else{
      aItem.animX=origA.x; aItem.animY=origA.y; bItem.animX=origB.x; bItem.animY=origB.y; if(cb) cb();
    }
  }
  requestAnimationFrame(stepAnim);
}

canvas.addEventListener('mousedown', e=>startSelect(e));
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); startSelect(e.touches[0]); });

function startSelect(e){
  if(gameEnded || animating) return;
  const rect = canvas.getBoundingClientRect();
  const c = Math.floor((e.clientX-rect.left)/CELL);
  const r = Math.floor((e.clientY-rect.top)/CELL);
  if(r<0||r>=ROWS||c<0||c>=COLS) return;
  if(!first) first=[r,c];
  else{ const [r0,c0]=first; if(Math.abs(r-r0)+Math.abs(c-c0)===1) animateSwap(r0,c0,r,c); first=null;}
  drawGrid();
}

function startTimer(){
  timer=120; gameEnded=false; score=0;
  scoreEl.textContent=`Punkte: ${score}`;
  scoreEl.style.display='block'; timerEl.style.display='block';
  canvas.style.display='block'; startButton.style.display='none';
  timerEl.textContent=formatTime(timer);
  timerInterval=setInterval(()=>{
    timer--; timerEl.textContent=formatTime(timer); scoreEl.textContent=`Punkte: ${score}`;
    if(timer<=0){ clearInterval(timerInterval); finishGame(); }
  },1000);
}

function formatTime(s){
  const m=Math.floor(s/60).toString().padStart(2,'0');
  const sec=(s%60).toString().padStart(2,'0');
  return `Zeit: ${m}:${sec}`;
}

function finishGame(){
  gameEnded=true;
  canvas.style.display='none'; scoreEl.style.display='none'; timerEl.style.display='none';
  try{ bgMusic.pause(); }catch(e){}
  try{ endMusic.currentTime=0; endMusic.volume=1; endMusic.play(); }catch(e){}
  endScoreEl.textContent=`Punkte: ${score}`;
  endScoreEl.style.display='block';
}

startButton.addEventListener('click', ()=>{
  endScoreEl.style.display='none';
  scoreEl.style.display='block'; timerEl.style.display='block';
  try{ bgMusic.currentTime=0; bgMusic.volume=1; bgMusic.play();}catch(e){}
  initGrid(); drawGrid(); startTimer();
  setTimeout(()=>resolveMatchesSafely(),80);
});

function resolveMatchesSafely(){ if(!animating && !gameEnded) resolveMatches(); }

canvas.style.display='none';
scoreEl.style.display='none';
timerEl.style.display='none';
endScoreEl.style.display='none';
startButton.style.display='inline-block';
</script>
</body>
</html>
