<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Match-3 Spiel (korrigiert)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html,body{
    margin:0; padding:0; width:100%; height:100%;
    font-family:Arial, sans-serif;
    background-image: url('backgroundImage.png');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    display:flex; align-items:center; justify-content:center;
  }
  canvas{
    width:360px; height:360px;
    image-rendering: pixelated;
    background: transparent;
    display:none;
  }
  #startButton{
    font-size:16px; padding:10px 20px; color:#fff;
    background:#222; border:none; cursor:pointer;
  }
  #score,#timer{
    position: absolute; top:10px; font-size:20px; color:#fff; display:none;
  }
  #score{ left:10px; }
  #timer{ right:10px; }
  #endScore{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    font-size:42px; color:gold; display:none; text-align:center;
  }
</style>
</head>
<body>
  <canvas id="gameCanvas" width="360" height="360"></canvas>
  <button id="startButton" disabled>Bilder laden…</button>
  <div id="score">Punkte: 0</div>
  <div id="timer">Zeit: 02:00</div>
  <div id="endScore"></div>

  <audio id="plopSound" src="plop.mp3"></audio>
  <audio id="bgMusic" src="background.mp3" loop></audio>
  <audio id="failSound" src="failSound.mp3"></audio>
  <audio id="endMusic" src="endMusic.mp3"></audio>

<script>
/* ---------- Setup & Assets ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const startButton = document.getElementById('startButton');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const endScoreEl = document.getElementById('endScore');

const plopSound = document.getElementById('plopSound');
const bgMusic = document.getElementById('bgMusic');
const failSound = document.getElementById('failSound');
const endMusic = document.getElementById('endMusic');

const COLS = 6, ROWS = 6;
const CANVAS_SIZE = 360;
const CELL = CANVAS_SIZE / COLS;

const imageSources = ["item1.png","item2.png","item3.png","item4.png"];
let images = [];

let grid = [];
let score = 0;
let animating = false;
let first = null;
let timer = 120;
let timerInterval = null;
let gameEnded = false;

/* ---------- Preload images ---------- */
async function preloadImages(list){
  startButton.disabled = true;
  startButton.textContent = "Bilder laden…";
  images = await Promise.all(list.map(src => new Promise(resolve=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = ()=>resolve(null);
    img.src = src;
  })));
  startButton.disabled = false;
  startButton.textContent = "Spiel starten & Sound freigeben";
}
preloadImages(imageSources);

/* ---------- Grid initialisieren ---------- */
function initGrid(){
  grid = [];
  for(let r=0;r<ROWS;r++){
    const row = [];
    for(let c=0;c<COLS;c++){
      let available = [0,1,2,3];
      if(c>=2 && row[c-1].imgIndex === row[c-2].imgIndex) available = available.filter(i=>i!==row[c-1].imgIndex);
      if(r>=2 && grid[r-1][c].imgIndex === grid[r-2][c].imgIndex) available = available.filter(i=>i!==grid[r-1][c].imgIndex);
      const idx = available[Math.floor(Math.random()*available.length)];
      row.push({ imgIndex: idx, row: r, col: c, animX: c, animY: r, removed:false });
    }
    grid.push(row);
  }
}

/* ---------- Zeichnen ---------- */
function drawGrid(shrinkMap = {}){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(gameEnded) return;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const item = grid[r][c];
      if(!item) continue;
      let size = CELL - 2;
      if(first && first[0]===r && first[1]===c && !animating) size *= 0.8;
      if(shrinkMap[`${r}_${c}`]) size *= shrinkMap[`${r}_${c}`];
      const x = item.animX * CELL + (CELL - size)/2;
      const y = item.animY * CELL + (CELL - size)/2;
      const img = images[item.imgIndex];
      if(img) ctx.drawImage(img, x, y, size, size);
    }
  }
}

/* ---------- Match-Funktionen ---------- */
function findMatches(){
  const matched = [];
  for(let r=0;r<ROWS;r++){
    let count = 1;
    for(let c=1;c<COLS;c++){
      if(grid[r][c].imgIndex === grid[r][c-1].imgIndex) count++;
      else { if(count>=3) for(let k=0;k<count;k++) matched.push([r, c-1-k]); count=1; }
    }
    if(count>=3) for(let k=0;k<count;k++) matched.push([r, COLS-1-k]);
  }
  for(let c=0;c<COLS;c++){
    let count = 1;
    for(let r=1;r<ROWS;r++){
      if(grid[r][c].imgIndex === grid[r-1][c].imgIndex) count++;
      else { if(count>=3) for(let k=0;k<count;k++) matched.push([r-1-k, c]); count=1; }
    }
    if(count>=3) for(let k=0;k<count;k++) matched.push([ROWS-1-k, c]);
  }
  return matched;
}

function swapData(r1,c1,r2,c2){
  const t = grid[r1][c1].imgIndex;
  grid[r1][c1].imgIndex = grid[r2][c2].imgIndex;
  grid[r2][c2].imgIndex = t;
}

function hasMoves(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(c < COLS-1){
        swapData(r,c,r,c+1);
        if(findMatches().length>0){ swapData(r,c,r,c+1); return true; }
        swapData(r,c,r,c+1);
      }
      if(r < ROWS-1){
        swapData(r,c,r+1,c);
        if(findMatches().length>0){ swapData(r,c,r+1,c); return true; }
        swapData(r,c,r+1,c);
      }
    }
  }
  return false;
}

/* ---------- Matches auflösen ---------- */
function resolveMatches(){
  if(gameEnded) return;
  const matched = findMatches();
  if(matched.length === 0){
    if(!hasMoves()) shuffleGrid();
    return;
  }
  plopSound.currentTime = 0; plopSound.volume = 1; plopSound.play();
  animating = true;
  const shrinkMap = {};
  const counted = {};
  matched.forEach(([r,c]) => { counted[`${r}_${c}`] = true; });
  const gained = Object.keys(counted).length;
  score += gained;
  scoreEl.textContent = `Punkte: ${score}`;
  Object.keys(counted).forEach(key => {
    const [r,c] = key.split('_').map(Number);
    shrinkMap[key] = 1;
    grid[r][c].removed = true;
  });
  function shrinkStep(){
    let done = true;
    for(const k in shrinkMap){
      shrinkMap[k] -= 0.06;
      if(shrinkMap[k] > 0) done = false;
    }
    drawGrid(shrinkMap);
    if(!done) requestAnimationFrame(shrinkStep);
    else fallItems();
  }
  shrinkStep();
}

/* ---------- Fallen & Animation ---------- */
function fallItems(){
  for(let c=0;c<COLS;c++){
    let write = ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(!grid[r][c].removed){
        if(write !== r){
          grid[write][c].imgIndex = grid[r][c].imgIndex;
          grid[write][c].animY = r;
        }
        write--;
      }
    }
    for(let r=write;r>=0;r--){
      grid[r][c].imgIndex = Math.floor(Math.random()*images.length);
      grid[r][c].animY = -1;
    }
    for(let r=0;r<ROWS;r++) grid[r][c].removed = false;
  }
  animateFalling();
}

function animateFalling(){
  animating = true;
  const duration = 300;
  const start = performance.now();
  const starts = grid.map(row => row.map(item => item.animY));
  function step(ts){
    const t = Math.min((ts - start)/duration, 1);
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const item = grid[r][c];
        item.animY = starts[r][c]*(1-t) + item.row*t;
      }
    }
    drawGrid();
    if(t < 1) requestAnimationFrame(step);
    else {
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) grid[r][c].animY = grid[r][c].row;
      animating = false;
      if(!gameEnded) resolveMatches();
    }
  }
  requestAnimationFrame(step);
}

/* ---------- Shuffle ---------- */
function shuffleGrid(){
  animating = true;
  const all = [];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) all.push(grid[r][c].imgIndex);
  let ok = false;
  while(!ok){
    const copy = [...all];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const idx = Math.floor(Math.random()*copy.length);
        grid[r][c].imgIndex = copy.splice(idx,1)[0];
        grid[r][c].animX = c;
        grid[r][c].animY = r;
      }
    }
    if(hasMoves()) ok = true;
  }
  drawGrid();
  animating = false;
}

/* ---------- Swap-Animation ---------- */
function animateSwap(r1,c1,r2,c2){
  if(animating || gameEnded) return;
  animating = true;
  const a = grid[r1][c1];
  const b = grid[r2][c2];
  const startA = { x: a.animX, y: a.animY };
  const startB = { x: b.animX, y: b.animY };
  const frames = 12; let step = 0;
  function doStep(){
    step++;
    const t = step / frames;
    a.animX = startA.x*(1-t) + startB.x*t;
    a.animY = startA.y*(1-t) + startB.y*t;
    b.animX = startB.x*(1-t) + startA.x*t;
    b.animY = startB.y*(1-t) + startA.y*t;
    drawGrid();
    if(step < frames) requestAnimationFrame(doStep);
    else {
      swapData(r1,c1,r2,c2);
      a.animX = a.col; a.animY = a.row;
      b.animX = b.col; b.animY = b.row;
      drawGrid();
      const matched = findMatches();
      if(matched.length > 0) resolveMatches();
      else{
        failSound.currentTime = 0; failSound.volume = 1; failSound.play();
        swapData(r1,c1,r2,c2);
        animateRevert(a,b,startA,startB,()=>{ animating=false; drawGrid(); });
      }
    }
  }
  requestAnimationFrame(doStep);
}

function animateRevert(aItem,bItem,origA,origB,cb){
  const frames = 10; let step=0;
  const startA = {x:aItem.animX, y:aItem.animY};
  const startB = {x:bItem.animX, y:bItem.animY};
  function stepAnim(){
    step++;
    const t = step/frames;
    aItem.animX = startA.x*(1-t) + origA.x*t;
    aItem.animY = startA.y*(1-t) + origA.y*t;
    bItem.animX = startB.x*(1-t) + origB.x*t;
    bItem.animY = startB.y*(1-t) + origB.y*t;
    drawGrid();
    if(step < frames) requestAnimationFrame(stepAnim);
    else{
      aItem.animX = origA.x; aItem.animY = origA.y;
      bItem.animX = origB.x; bItem.animY = origB.y;
      if(cb) cb();
    }
  }
  requestAnimationFrame(stepAnim);
}

/* ---------- Auswahl / Input ---------- */
canvas.addEventListener('mousedown', e=>startSelect(e));
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); startSelect(e.touches[0]); });

function startSelect(e){
  if(gameEnded || animating) return;
  const rect = canvas.getBoundingClientRect();
  const c = Math.floor((e.clientX-rect.left)/CELL);
  const r = Math.floor((e.clientY-rect.top)/CELL);
  if(!first) first=[r,c];
  else{
    const [r0,c0] = first;
    if(Math.abs(r-r0)+Math.abs(c-c0)===1) animateSwap(r0,c0,r,c);
    first=null;
  }
  drawGrid();
}

/* ---------- Timer & Flow ---------- */
function startTimer(){
  timer=120; gameEnded=false; score=0;
  scoreEl.textContent=`Punkte: ${score}`;
  scoreEl.style.display='block'; timerEl.style.display='block';
  canvas.style.display='block'; startButton.style.display='none';
  timerEl.textContent = formatTime(timer);
  timerInterval = setInterval(()=>{
    timer--;
    timerEl.textContent = formatTime(timer);
    scoreEl.textContent=`Punkte: ${score}`;
    if(timer<=0){ clearInterval(timerInterval); finishGame(); }
  },1000);
}

function formatTime(s){
  const m = Math.floor(s/60).toString().padStart(2,'0');
  const sec = (s%60).toString().padStart(2,'0');
  return `Zeit: ${m}:${sec}`;
}

function finishGame(){
  gameEnded = true;
  canvas.style.display='none';
  scoreEl.style.display='none';
  timerEl.style.display='none';
  bgMusic.pause();
  endMusic.currentTime=0; endMusic.volume=1; endMusic.play();
  endScoreEl.textContent=`Punkte: ${score}`;
  endScoreEl.style.display='block';
}

/* ---------- Start button ---------- */
startButton.addEventListener('click', ()=>{
  endScoreEl.style.display='none';
  scoreEl.style.display='block';
  timerEl.style.display='block';
  bgMusic.currentTime=0; bgMusic.volume=1; bgMusic.play();
  initGrid();
  drawGrid();
  startTimer();
  setTimeout(()=>resolveMatchesSafely(),80);
});

function resolveMatchesSafely(){
  if(!animating && !gameEnded) resolveMatches();
}

/* ---------- Initial UI ---------- */
canvas.style.display='none';
scoreEl.style.display='none';
timerEl.style.display='none';
endScoreEl.style.display='none';
startButton.style.display='inline-block';
</script>
</body>
</html>
